# ============================================================================
# Azure Deployment Workflow
# ============================================================================
# This workflow deploys the Fencemark application to Azure Container Apps
# using Bicep infrastructure as code.
#
# Deployment Flow:
#   1. Build and test the solution
#   2. Publish application artifacts
#   3. Deploy Bicep infrastructure to Azure
#   4. Build and push Docker images to Azure Container Registry
#   5. Update Container Apps with new images
#
# Environments:
#   - dev: Auto-deploys on push to main
#   - staging: Manual deployment with approval
#   - prod: Manual deployment with approval
#
# Authentication: Uses OpenID Connect (OIDC) for secure, credential-less auth
#
# For more information, see: CI-CD.md
# ============================================================================

name: Deploy to Azure

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/PULL_REQUEST_TEMPLATE.md'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

# Prevent concurrent deployments to same environment
concurrency:
  group: deploy-${{ github.ref }}-${{ github.event.inputs.environment || 'dev' }}
  cancel-in-progress: false

permissions:
  id-token: write       # Required for OIDC authentication with Azure
  checks: write         # Write check run results
  pull-requests: write  # Comment deployment status on PRs
  contents: read        # Read repository contents
  packages: write       # Push container images to ACR

env:
  AZURE_LOCATION: 'australiaeast'
  DOTNET_VERSION: '10.0.x'

jobs:
  # ============================================================================
  # Build and Test Job
  # ============================================================================
  # Builds the solution, runs tests, and publishes artifacts for deployment.
  # Artifacts are retained for 1 day to support multiple environment deployments.
  # ============================================================================
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore

      - name: Build solution
        run: dotnet build --no-restore --configuration Release

      - name: Run tests
        run: dotnet test --no-build --configuration Release --report-xunit-trx --results-directory TestResults

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: TestResults/*.trx
          if-no-files-found: warn
          retention-days: 30

      - name: Annotate test failures
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: dotnet-tests
          path: TestResults/*.trx
          reporter: dotnet-trx

      - name: Generate image metadata
        id: meta
        run: |
          echo "tags=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "short-sha=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT

      - name: Publish API Service
        run: dotnet publish fencemark.ApiService/fencemark.ApiService.csproj -c Release -o ./publish/apiservice --no-build

      - name: Publish Web Frontend
        run: dotnet publish fencemark.Web/fencemark.Web.csproj -c Release -o ./publish/webfrontend --no-build

      - name: Upload API Service artifact
        uses: actions/upload-artifact@v4
        with:
          name: apiservice-publish
          path: ./publish/apiservice
          retention-days: 1

      - name: Upload Web Frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: webfrontend-publish
          path: ./publish/webfrontend
          retention-days: 1

  # ============================================================================
  # Deploy Central App Configuration
  # ============================================================================
  # Deploys the centralized App Configuration store that serves all environments.
  # This is deployed once and shared across dev, staging, and prod using labels.
  # Uses a conditional check to avoid redeploying if it already exists.
  # ============================================================================
  deploy-central-config:
    name: Deploy Central App Config
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check if central config resource group exists
        id: check-rg
        continue-on-error: true
        run: |
          az group show --name rg-fencemark-central-config
          echo "exists=$?" >> $GITHUB_OUTPUT

      - name: Deploy Central App Configuration
        if: steps.check-rg.outputs.exists != '0'
        uses: azure/bicep-deploy@v2
        with:
          type: deployment
          operation: create
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          scope: subscription
          location: ${{ env.AZURE_LOCATION }}
          template-file: ./infra/central-appconfig.bicep
          parameters-file: ./infra/central-appconfig.bicepparam

      - name: Verify Central App Configuration exists
        run: |
          az appconfig show --name appcs-fencemark --resource-group rg-fencemark-central-config

  # ============================================================================
  # Deploy to Dev Environment
  # ============================================================================
  # Automatically deploys to dev on push to main (excluding doc changes).
  # Can also be triggered manually via workflow_dispatch.
  #
  # Steps:
  #   1. Authenticate with Azure using OIDC
  #   2. Deploy infrastructure using Bicep templates
  #   3. Download build artifacts
  #   4. Build and push Docker images to ACR
  #   5. Update Container Apps with new images
  # ============================================================================
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    needs: [build, deploy-central-config]
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'dev')
    environment: dev
    timeout-minutes: 30
    env:
      RESOURCE_GROUP: rg-fencemark-dev
      API_SERVICE_NAME: ca-apiservice
      WEB_FRONTEND_NAME: ca-webfrontend
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          auth-type: FEDERATED
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep infrastructure to Dev
        uses: azure/bicep-deploy@v2
        id: deploy-infra
        with:
          type: deployment
          operation: create
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          scope: subscription
          location: ${{ env.AZURE_LOCATION }}
          template-file: ./infra/main.bicep
          parameters-file: ./infra/dev.bicepparam

      - name: Get deployment outputs
        id: get-outputs
        run: |
          echo "acr-name=${{ steps.deploy-infra.outputs.containerRegistryName }}"      >> $GITHUB_OUTPUT
          echo "acr-login-server=${{ steps.deploy-infra.outputs.containerRegistryLoginServer }}" >> $GITHUB_OUTPUT
          echo "api-service-name=${{ steps.deploy-infra.outputs.apiServiceName }}"     >> $GITHUB_OUTPUT
          echo "web-frontend-name=${{ steps.deploy-infra.outputs.webFrontendName }}"   >> $GITHUB_OUTPUT
          echo "resource-group=${{ steps.deploy-infra.outputs.resourceGroupName }}"    >> $GITHUB_OUTPUT
          echo "web-frontend-url=${{ steps.deploy-infra.outputs.webFrontendUrl }}"     >> $GITHUB_OUTPUT

      - name: Download API Service artifact
        uses: actions/download-artifact@v4
        with:
          name: apiservice-publish
          path: ./publish/apiservice

      - name: Download Web Frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: webfrontend-publish
          path: ./publish/webfrontend

      - name: Log in to Azure Container Registry
        run: az acr login --name ${{ steps.get-outputs.outputs.acr-name }}

      - name: Build and push API Service image
        run: |
          IMAGE_TAG="${{ steps.get-outputs.outputs.acr-login-server }}/apiservice:${{ github.sha }}"
          docker build -t $IMAGE_TAG -f fencemark.ApiService/Dockerfile ./publish/apiservice
          docker push $IMAGE_TAG
          echo "API_IMAGE=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build and push Web Frontend image
        run: |
          IMAGE_TAG="${{ steps.get-outputs.outputs.acr-login-server }}/webfrontend:${{ github.sha }}"
          docker build -t $IMAGE_TAG -f fencemark.Web/Dockerfile ./publish/webfrontend
          docker push $IMAGE_TAG
          echo "WEB_IMAGE=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy API Service to Container App
        run: |
          az containerapp update \
            --name ${{ steps.get-outputs.outputs.api-service-name }} \
            --resource-group ${{ steps.get-outputs.outputs.resource-group }} \
            --image ${{ env.API_IMAGE }}

      - name: Deploy Web Frontend to Container App
        run: |
          az containerapp update \
            --name ${{ steps.get-outputs.outputs.web-frontend-name }} \
            --resource-group ${{ steps.get-outputs.outputs.resource-group }} \
            --image ${{ env.WEB_IMAGE }}

      - name: Wait for deployment to stabilize
        run: sleep 30

      # Note: API Service health check skipped - it's an internal service (ingressExternal: false)
      # and not accessible from external networks. The Web Frontend health check validates
      # the deployment since it depends on the API service.

      - name: Health Check - Web Frontend
        id: health-check-web
        continue-on-error: true
        run: |
          WEB_URL="${{ steps.get-outputs.outputs.web-frontend-url }}"
          echo "Web URL: $WEB_URL"
          
          # Try health check endpoint with retries
          MAX_RETRIES=5
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $WEB_URL/health || echo "000")
            echo "Health check attempt $((RETRY_COUNT + 1)): HTTP $HTTP_CODE"
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "âœ… Web Frontend health check passed"
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              sleep 10
            fi
          done
          
          echo "âŒ Web Frontend health check failed after $MAX_RETRIES attempts"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1

      - name: Smoke Test - Home Page Accessibility
        id: smoke-test-home
        if: steps.health-check-web.outputs.status == 'success'
        continue-on-error: true
        run: |
          WEB_URL="${{ steps.get-outputs.outputs.web-frontend-url }}"
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $WEB_URL || echo "000")
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "âœ… Home page is accessible"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Home page returned HTTP $HTTP_CODE"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Report Health Check Status
        if: always()
        run: |
          echo "## ðŸ¥ Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.health-check-web.outputs.status }}" = "success" ]; then
            echo "âœ… **Web Frontend:** Healthy" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Web Frontend:** Unhealthy" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.smoke-test-home.outputs.status }}" = "success" ]; then
            echo "âœ… **Smoke Test:** Passed" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.smoke-test-home.outputs.status }}" = "failed" ]; then
            echo "âŒ **Smoke Test:** Failed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ **Smoke Test:** Skipped (health check failed)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Dev Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** dev" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AZURE_LOCATION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** ${{ steps.get-outputs.outputs.resource-group }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ³ Container Images" >> $GITHUB_STEP_SUMMARY
          echo "- **API Service:** \`${{ env.API_IMAGE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Frontend:** \`${{ env.WEB_IMAGE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Application URL" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.get-outputs.outputs.web-frontend-url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ” Authentication Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **CIAM Tenant:** devfencemark.onmicrosoft.com" >> $GITHUB_STEP_SUMMARY
          echo "- **Client ID:** 5b204301-0113-4b40-bd2e-e0ef8be99f48" >> $GITHUB_STEP_SUMMARY
          echo "- **Key Vault:** kv-ciambfwyw65gna5lu" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Deploy to Staging Environment
  # ============================================================================
  # Manual deployment only (via workflow_dispatch).
  # Used for pre-production validation, QA, and UAT.
  # Requires approval from designated approvers.
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build, deploy-central-config]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging'
    environment: staging
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          auth-type: FEDERATED
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep infrastructure to Staging
        uses: azure/bicep-deploy@v2
        id: deploy-infra
        with:
          type: deployment
          operation: create
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          scope: subscription
          location: ${{ env.AZURE_LOCATION }}
          template-file: ./infra/main.bicep
          parameters-file: ./infra/staging.bicepparam
          deployment-name: main

      - name: Get deployment outputs
        id: get-outputs
        run: |
          OUTPUTS=$(az deployment sub show --name main --query properties.outputs -o json)
          echo "acr-name=$(echo $OUTPUTS | jq -r '.containerRegistryName.value')" >> $GITHUB_OUTPUT
          echo "acr-login-server=$(echo $OUTPUTS | jq -r '.containerRegistryLoginServer.value')" >> $GITHUB_OUTPUT
          echo "api-service-name=$(echo $OUTPUTS | jq -r '.apiServiceName.value')" >> $GITHUB_OUTPUT
          echo "web-frontend-name=$(echo $OUTPUTS | jq -r '.webFrontendName.value')" >> $GITHUB_OUTPUT
          echo "resource-group=$(echo $OUTPUTS | jq -r '.resourceGroupName.value')" >> $GITHUB_OUTPUT
          echo "web-frontend-url=$(echo $OUTPUTS | jq -r '.webFrontendUrl.value')" >> $GITHUB_OUTPUT

      - name: Download API Service artifact
        uses: actions/download-artifact@v4
        with:
          name: apiservice-publish
          path: ./publish/apiservice

      - name: Download Web Frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: webfrontend-publish
          path: ./publish/webfrontend

      - name: Log in to Azure Container Registry
        run: az acr login --name ${{ steps.get-outputs.outputs.acr-name }}

      - name: Build and push API Service image
        run: |
          IMAGE_TAG="${{ steps.get-outputs.outputs.acr-login-server }}/apiservice:${{ github.sha }}"
          docker build -t $IMAGE_TAG -f fencemark.ApiService/Dockerfile ./publish/apiservice
          docker push $IMAGE_TAG
          echo "API_IMAGE=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build and push Web Frontend image
        run: |
          IMAGE_TAG="${{ steps.get-outputs.outputs.acr-login-server }}/webfrontend:${{ github.sha }}"
          docker build -t $IMAGE_TAG -f fencemark.Web/Dockerfile ./publish/webfrontend
          docker push $IMAGE_TAG
          echo "WEB_IMAGE=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy API Service to Container App
        run: |
          az containerapp update \
            --name ${{ steps.get-outputs.outputs.api-service-name }} \
            --resource-group ${{ steps.get-outputs.outputs.resource-group }} \
            --image ${{ env.API_IMAGE }}

      - name: Deploy Web Frontend to Container App
        run: |
          az containerapp update \
            --name ${{ steps.get-outputs.outputs.web-frontend-name }} \
            --resource-group ${{ steps.get-outputs.outputs.resource-group }} \
            --image ${{ env.WEB_IMAGE }}

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** staging" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AZURE_LOCATION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** ${{ steps.get-outputs.outputs.resource-group }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ³ Container Images" >> $GITHUB_STEP_SUMMARY
          echo "- **API Service:** \`${{ env.API_IMAGE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Frontend:** \`${{ env.WEB_IMAGE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Application URL" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.get-outputs.outputs.web-frontend-url }}" >> $GITHUB_STEP_SUMMARY

  # ============================================================================
  # Deploy to Production Environment
  # ============================================================================
  # Manual deployment only (via workflow_dispatch).
  # Used for live user-facing application.
  # Requires approval from designated approvers.
  # High availability configuration with minimum 2 replicas.
  # ============================================================================
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-central-config]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod'
    environment: prod
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          auth-type: FEDERATED
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy Bicep infrastructure to Production
        uses: azure/bicep-deploy@v2
        id: deploy-infra
        with:
          type: deployment
          operation: create
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}
          scope: subscription
          location: ${{ env.AZURE_LOCATION }}
          template-file: ./infra/main.bicep
          parameters-file: ./infra/prod.bicepparam
          deployment-name: main

      - name: Get deployment outputs
        id: get-outputs
        run: |
          OUTPUTS=$(az deployment sub show --name main --query properties.outputs -o json)
          echo "acr-name=$(echo $OUTPUTS | jq -r '.containerRegistryName.value')" >> $GITHUB_OUTPUT
          echo "acr-login-server=$(echo $OUTPUTS | jq -r '.containerRegistryLoginServer.value')" >> $GITHUB_OUTPUT
          echo "api-service-name=$(echo $OUTPUTS | jq -r '.apiServiceName.value')" >> $GITHUB_OUTPUT
          echo "web-frontend-name=$(echo $OUTPUTS | jq -r '.webFrontendName.value')" >> $GITHUB_OUTPUT
          echo "resource-group=$(echo $OUTPUTS | jq -r '.resourceGroupName.value')" >> $GITHUB_OUTPUT
          echo "web-frontend-url=$(echo $OUTPUTS | jq -r '.webFrontendUrl.value')" >> $GITHUB_OUTPUT

      - name: Download API Service artifact
        uses: actions/download-artifact@v4
        with:
          name: apiservice-publish
          path: ./publish/apiservice

      - name: Download Web Frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: webfrontend-publish
          path: ./publish/webfrontend

      - name: Log in to Azure Container Registry
        run: az acr login --name ${{ steps.get-outputs.outputs.acr-name }}

      - name: Build and push API Service image
        run: |
          IMAGE_TAG="${{ steps.get-outputs.outputs.acr-login-server }}/apiservice:${{ github.sha }}"
          docker build -t $IMAGE_TAG -f fencemark.ApiService/Dockerfile ./publish/apiservice
          docker push $IMAGE_TAG
          echo "API_IMAGE=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Build and push Web Frontend image
        run: |
          IMAGE_TAG="${{ steps.get-outputs.outputs.acr-login-server }}/webfrontend:${{ github.sha }}"
          docker build -t $IMAGE_TAG -f fencemark.Web/Dockerfile ./publish/webfrontend
          docker push $IMAGE_TAG
          echo "WEB_IMAGE=$IMAGE_TAG" >> $GITHUB_ENV

      - name: Deploy API Service to Container App
        run: |
          az containerapp update \
            --name ${{ steps.get-outputs.outputs.api-service-name }} \
            --resource-group ${{ steps.get-outputs.outputs.resource-group }} \
            --image ${{ env.API_IMAGE }}

      - name: Deploy Web Frontend to Container App
        run: |
          az containerapp update \
            --name ${{ steps.get-outputs.outputs.web-frontend-name }} \
            --resource-group ${{ steps.get-outputs.outputs.resource-group }} \
            --image ${{ env.WEB_IMAGE }}

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** prod" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AZURE_LOCATION }}" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** ${{ steps.get-outputs.outputs.resource-group }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ³ Container Images" >> $GITHUB_STEP_SUMMARY
          echo "- **API Service:** \`${{ env.API_IMAGE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Web Frontend:** \`${{ env.WEB_IMAGE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Application URL" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.get-outputs.outputs.web-frontend-url }}" >> $GITHUB_STEP_SUMMARY
